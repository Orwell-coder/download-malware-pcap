#!/usr/bin/env python3
# -*- coding:utf-8 -*-

from scapy.all import *
import os
import sys
import time


class PcapDecode:
    def __init__(self):
        try:
            # ETHER:读取以太网层协议配置文件
            with open('./protocol/ETHER', 'r', encoding='UTF-8') as f:
                ethers = f.readlines()
            self.ETHER_DICT = dict()
            for ether in ethers:
                ether = ether.strip().strip('\n').strip('\r').strip('\r\n')
                key, value = ether.split(':')
                self.ETHER_DICT[int(key)] = value  # 将配置文件中的信息(0257:Experimental)存入dict
            print('ETHER protocol loading completed!')

            # IP:读取IP层协议配置文件
            with open('./protocol/IP', 'r', encoding='UTF-8') as f:
                ips = f.readlines()
            self.IP_DICT = dict()
            for ip in ips:
                ip = ip.strip().strip('\n').strip('\r').strip('\r\n')
                key, value = ip.split(':')
                self.IP_DICT[int(key)] = value  # 将配置文件中的信息(41:IPv6)存入dic
            print('IP protocol loading completed!')

            # PORT:读取应用层协议端口配置文件
            with open('./protocol/PORT', 'r', encoding='UTF-8') as f:
                ports = f.readlines()
            self.PORT_DICT = dict()
            for port in ports:
                port = port.strip().strip('\n').strip('\r').strip('\r\n')
                key, value = port.split(':')
                self.PORT_DICT[int(key)] = value  # 如：21:FTP
            print('PORT protocol loading completed!')

            # TCP:读取TCP层协议配置文件
            with open('./protocol/TCP', 'r', encoding='UTF-8') as f:
                tcps = f.readlines()
            self.TCP_DICT = dict()
            for tcp in tcps:
                tcp = tcp.strip().strip('\n').strip('\r').strip('\r\n')
                key, value = tcp.split(':')
                self.TCP_DICT[int(key)] = value  # 465:SMTPS
            print('TCP protocol loading completed!')

            # UDP:读取UDP层协议配置文件
            with open('./protocol/UDP', 'r', encoding='UTF-8') as f:
                udps = f.readlines()
            self.UDP_DICT = dict()
            for udp in udps:
                udp = udp.strip().strip('\n').strip('\r').strip('\r\n')
                key, value = udp.split(':', 2)
                self.UDP_DICT[int(key)] = value  # 513:Who
            print('UDP protocol loading completed!')
        except IOError as e:
            print('IOError ', e)


    # 解析以太网层协议 ---ether_decode——ip_decode(tcp_decode or udp_decode)
    def ether_decode(self, p):
        data = dict()  # 解析出的信息以dict的形式保存
        if p.haslayer("Ether"):  # scapy.haslayer,将pcap包中的信息分层，再处理
            data = self.ip_decode(p)  # 解析IP层协议
            return data
        else:
            data['time'] = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(p.time))
            data['Source'] = 'Unknow'
            data['Destination'] = 'Unknow'
            data['Procotol'] = 'Unknow'
            data['len'] = len(corrupt_bytes(p))
            data['info'] = p.summary()
            return data

    # 解析IP层协议
    def ip_decode(self, p):
        data = dict()
        if p.haslayer("IP"):  # 2048:Internet IP (IPv4) ，分IPV4和IPV6和其他协议
            ip = p.getlayer("IP")
            if p.haslayer("TCP"):  # 6:TCP
                data = self.tcp_decode(p, ip)
                return data
            elif p.haslayer("UDP"):  # 17:UDP
                data = self.udp_decode(p, ip)
                return data
            else:
                if ip.proto in self.IP_DICT:  # 若ip分层中的协议信息在字典中，则提取ip分层中的源地址、目的地址、协议（转换）等
                    data['time'] = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(p.time))
                    data['Source'] = ip.src
                    data['Destination'] = ip.dst
                    data['Procotol'] = self.IP_DICT[ip.proto]
                    data['len'] = len(corrupt_bytes(p))
                    data['info'] = p.summary()
                    return data
                else:
                    data['time'] = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(p.time))
                    data['Source'] = ip.src
                    data['Destination'] = ip.dst
                    data['Procotol'] = 'IPv4'
                    data['len'] = len(corrupt_bytes(p))
                    data['info'] = p.summary()
                    return data
        elif p.haslayer("IPv6"):  # 34525:IPv6
            ipv6 = p.getlayer("IPv6")
            if p.haslayer("TCP"):  # 6:TCP
                data = self.tcp_decode(p, ipv6)
                return data
            elif p.haslayer("UDP"):  # 17:UDP
                data = self.udp_decode(p, ipv6)
                return data
            else:
                if ipv6.nh in self.IP_DICT:
                    data['time'] = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(p.time))
                    data['Source'] = ipv6.src
                    data['Destination'] = ipv6.dst
                    data['Procotol'] = self.IP_DICT[ipv6.nh]
                    data['len'] = len(corrupt_bytes(p))
                    data['info'] = p.summary()
                    return data
                else:
                    data['time'] = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(p.time))
                    data['Source'] = ipv6.src
                    data['Destination'] = ipv6.dst
                    data['Procotol'] = 'IPv6'
                    data['len'] = len(corrupt_bytes(p))
                    data['info'] = p.summary()
                    return data
        else:
            if p.type in self.ETHER_DICT:
                data['time'] = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(p.time))
                data['Source'] = p.src
                data['Destination'] = p.dst
                data['Procotol'] = self.ETHER_DICT[p.type]
                data['len'] = len(corrupt_bytes(p))
                data['info'] = p.summary()
                return data
            else:
                data['time'] = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(p.time))
                data['Source'] = p.src
                data['Destination'] = p.dst
                data['Procotol'] = hex(p.type)  # 若在字典中没有改协议，则以16进制的形式显示
                data['len'] = len(corrupt_bytes(p))
                data['info'] = p.summary()
                return data

    # 解析TCP层协议
    def tcp_decode(self, p, ip):
        data = dict()
        tcp = p.getlayer("TCP")
        data['time'] = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(p.time))
        data['Source'] = ip.src + ":" + str(ip.sport)
        data['Destination'] = ip.dst + ":" + str(ip.dport)
        data['len'] = len(corrupt_bytes(p))
        data['info'] = p.summary()
        if tcp.dport in self.PORT_DICT:  # 若端口信息在PORT_DICT\TCP_DICT中则转换为已知
            data['Procotol'] = self.PORT_DICT[tcp.dport]
        elif tcp.sport in self.PORT_DICT:
            data['Procotol'] = self.PORT_DICT[tcp.sport]
        elif tcp.dport in self.TCP_DICT:
            data['Procotol'] = self.TCP_DICT[tcp.dport]
        elif tcp.sport in self.TCP_DICT:
            data['Procotol'] = self.TCP_DICT[tcp.sport]
        else:
            data['Procotol'] = "TCP"
        return data

    # 解析UDP层协议
    def udp_decode(self, p, ip):
        data = dict()
        udp = p.getlayer("UDP")
        data['time'] = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(p.time))
        data['Source'] = ip.src + ":" + str(ip.sport)
        data['Destination'] = ip.dst + ":" + str(ip.dport)
        data['len'] = len(corrupt_bytes(p))
        data['info'] = p.summary()
        if udp.dport in self.PORT_DICT:  # 若端口信息在PORT_DICT\UDP_DICT中则转换为已知
            data['Procotol'] = self.PORT_DICT[udp.dport]
        elif udp.sport in self.PORT_DICT:
            data['Procotol'] = self.PORT_DICT[udp.sport]
        elif udp.dport in self.UDP_DICT:
            data['Procotol'] = self.UDP_DICT[udp.dport]
        elif udp.sport in self.UDP_DICT:
            data['Procotol'] = self.UDP_DICT[udp.sport]
        else:
            data['Procotol'] = "UDP"
        return data

    def get_all_pcap(self, PCAPS):
        """
        对于pcap文件进行文件处理，返回字典格式
        """
        pcaps = collections.OrderedDict()
        for count, i in enumerate(PCAPS, 1):
            pcaps[count] = self.ether_decode(i)
        return pcaps

    def get_filter_pcap(self, PCAPS, key, value):
        """
        将具体的协议进行筛选返回
        """
        pcaps = collections.OrderedDict()
        count = 1
        for p in PCAPS:
            pcap = self.ether_decode(p)
            if key == 'Procotol':
                if value == pcap.get('Procotol').upper():
                    pcaps[count] = pcap
                    count += 1
                else:
                    pass
            elif key == 'Source':
                if value == pcap.get('Source').upper():
                    pcaps[count] = pcap
                    count += 1
            elif key == 'Destination':
                if value == pcap.get('Destination').upper():
                    pcaps[count] = pcap
                    count += 1
            else:
                pass
        # 将pcap筛选后记录按序返回
        return pcaps

    def proto_filter(self, filter_type, value, PCAPS):
        """
        协议过滤，根据选择挑选出正确的协议显示
        可以根据"起始地址：端口","目的地址：端口","协议"筛选
        """
        if filter_type == u'all':
            pcaps = self.get_all_pcap(PCAPS)
        elif filter_type == u'proto':
            key = 'Procotol'
            value = str(value).strip().upper()
            pcaps = self.get_filter_pcap(PCAPS, key, value)
        elif filter_type == u'ipsrc':
            key = 'Source'
            value = str(value).strip().upper()
            pcaps = self.get_filter_pcap(PCAPS, key, value)
        elif filter_type == u'ipdst':
            key = 'Destination'
            value = str(value).strip().upper()
            pcaps = self.get_filter_pcap(PCAPS, key, value)
        else:
            pcaps = self.get_all_pcap(PCAPS)
        return pcaps


if __name__ == '__main__':

    PD = PcapDecode()  # 实例化该类为PD
    pcap_test = rdpcap("malware-traffic-analysis.net/extract_pcaps/2020-01-30-traffic-analysis-exercise.pcap")  # 这个demo.pcap包含3次连接
    data_result = []  # 将解析结果存入dict
    for p in pcap_test:
        result = PD.ether_decode(p)
        data_result.append(result)
        print(result)
    print("count: %d" % len(data_result))